# 자료구조(Data Structure)
## 리스트(List)
### 배열(Array)
- 정의 : 동일한 데이터 타입의 요소들을 순차적으로 저장하는 선형 데이터 구조
- 특징   
    - 동일한 데이터 타입의 요소들로만 구성
    - 요소들이 순차적으로 저장 - 메모리 상에서 연속된 공간에 데이터를 배치
    - 인덱스를 기반으로 배열의 요소에 접근
#### 고정 크기 배열 (Fixed-size Array)	
- 정의 : 미리 정의된 크기만큼의 메모리를 할당받아 동적으로 크기를 변경할 수 없는 배열
- 특징 : 선언시 단 한번만 메모리를 할당받음
- 장점 
    - 배열의 크기가 고정되어 있기 때문에 각 인덱스에 해당하는 메모리 주소를 빠르게 계산하여 접근 가능
    - 메모리 관리가 상대적으로 단순하고 일정한 성능을 보장
- 단점
    - 크기가 고정되어 있기 때문에 배열의 크기보다 데이터의 양이 적으면 메모리를 낭비하게될 가능성이 있음
    - 선언된 배열의 크기보다 더 많은 데이터를 저장해야 할 경우 새로운 배열을 만들어 데이터를 복사해야 함
- 예시
    <details><summary>C언어에서의 고정 크기 배열</summary>

    ```C
    int arr[5]; //고정 크기 배열 선언
    arr[0] = 10; //0번 인덱스에 10 할당
    ```
    </details>


#### 동적 배열 (Dynamic Array)
- 정의 : 배열의 크기가 동적으로 변화할 수 있는 배열
- 특징
    - 크기가 변경될 때 마다 새로운 메모리 블록을 할당하고, 기존 배열의 데이터를 새로운 배열로 복사
- 장점
    -  크기가 동적으로 변화하므로 선언시 필요한 크기를 예측할 필요가 없음
    -  데이터의 양에 따라 유동적으로 배열의 크기를 변경하여 메모리 낭비를 줄임
- 단점
    -  배열 크기가 늘어날 때마다 메모리 재할당과 복사가 발생하여 성능에 영향을 줄 수 있음
- 예시
    <details><summary>C언어에서의 동적 배열</summary>

    ```C
    int* arr = (int*)malloc(sizeof(int) * 10); //동적 배열, 크기 10 할당
    free(arr) //메모리 반납
    ```
    </details>

### 연결 리스트 (Linked List)	
- 정의 : 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 선형 자료 구조
- 특징
    -  노드가 추가되거나 제거되면서 크기가 동적으로 변화할 수 있음
    -  각 노드가 메모리의 다른 위치에 저장되며, 노드들이 포인터를 통해 연결되어 있음
    -  삽입 삭제시 포인터만 변경하면 되어 배열보다 효율적이나 특정 요소를 찾을 때 전체를 순회해야해 검색 시간이 배열보다 느림
#### 단일 연결 리스트 (Singly-Linked List)
- 정의 : 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가지고 일렬로 연결되어 있는 리스트
- 특징
    -  각 노드의 포인터는 다음 노드만을 가리킴
- 장점
    -  연결 리스트의 장점을 가지나 단일 연결 리스트만의 장점은 없음
- 단점
    -  특정 노드에 접근하기 위해서 헤드부터 원하는 노드까지 탐색해야 함
    -  역방향 탐색이 불가능함
- 예시
    <details><summary>단일 연결 리스트 예시</summary>

    ![단일 연결 리스트 이미지](./img/data_structure/singly_linked_list.png)   
    Image source : GeeksforGeeks

    </details>

#### 이중 연결 리스트 (Doubly-Linked List)		
- 정의 : 각 노드가 데이터와 이전과 다음 노드를 가리키는 포인터를 가지고 일렬로 연결되어 있는 리스트
- 특징
    -  각 노드의 포인터가 이전 노드와 다음 노드를 가리키는 포인터를 가지고 있음
- 장점
    -  양방향 탐색이 가능함
    -  단일 연결 리스트에 비해 노드의 이전 노드를 탐색하고 삭제하기가 용이
    -  헤드 노드와 테일 노드의 삽입 삭제가 용이
- 단점
    -  단일 연결 리스트에 비해 포인터를 하나 더 사용하여 메모리를 더 많이 사용
    -  단일 연결 리스트보다 포인터 관리가 복잡
- 예시


#### 원형 연결 리스트 (Circular-Linked List)		
- 정의 : 리스트의 마지막 노드가 헤드 노드를 가리켜서 노드들이 원형으로 연결되어 있는 리스트
- 특징
    -  단일 연결 리스트와 이중 연결 리스트 모두에서 구현이 가능
    -  마지막 노드의 포인터가 헤드 노드를 가리켜 리스트 전체가 순환가능한 구
- 장점
    -  리스트의 끝에서 처음 노드로 이동할 수 있어 순환 작업에 유리(ex: Round-Robin 스케줄링)
    -  어느 노드에서든 탐색을 시작하여 전체 탐색이 가능
- 단점
    -  순환 구조로 인해 종료 조건을 명확히 하지 않으면 무한 루프에 빠질 위험이 있음
- 예시


#### 다중 연결 리스트 (Multi-Linked List)
- 정의 : 앞의 연결 리스트들과 달리 단방향, 양방향으로 연결된 것이 아니라 각 노드가 여러개의 포인터를 가져 포인터들을 통해 여러 노드에 연결되어 있는 리스트
- 특징
    -  각 노드가 여러개의 포인터를 가지며 각각 다른 방향이나 리스트를 가리킬 수 있음
    -  행렬과 같은 다차원 데이터를 연결 리스트로 표현할 때 사용 가능
- 장점
    -  데이터가 여러 연결 리스트의 노드로 포함될 수 있어 복잡한 관계 표현 가능
    -  여러 방향으로 연결이 가능하여 데이터 탐색이나 관계 표현이 유연
- 단점
    - 다수의 포인터를 관리해야 하므로 삽입, 삭제, 탐색의 구현이 매우 복잡하고 포인터 관리가 부담스러움
    - 다수의 포인터를 사용하므로 타 연결 리스트들에 비해 메모리를 더 많이 사용
- 예시
  
---
## 스택
- 정의 : 한쪽 끝에서만 데이터를 넣고 뺄 수 있는 제한된 접근 형태를 가진 LIFO형태의 선형 자료구조
- 특징
    -  처음 들어온 데이터가 제일 아래 놓이고 그 위로 데이터가 쌓이는 형태를 가짐
    -  데이터의 삽입, 삭제가 스택의 제일 위에 위치한 데이터를 가리키는 Top에서 이루어짐
- 예시
    <details><summary></summary>


    </details>

### 배열 기반 스택 (Array-based Stack)			
- 정의 : 배열을 이용하여 스택 자료 구조를 구현한 형태
- 특징
    -  일반적으로 배열의 크기에 따라 스택의 크기가 고정되어있음
    -  배열의 인덱스를 사용하여 특정 위치의 데이터에 접근 가능
- 장점
    -  배열 구조를 이용하므로 구현이 간단함
    -  데이터가 메모리에 연속적으로 저장되므로 캐시 활용이 유리하고 속도가 빠름
- 단점
    -  고정 크기 배열을 사용한다면 배열 크기를 초과할 때 스택 오버플로우가 발생
    -  스택의 크기를 사전에 예측하기 어렵다면 메모리 낭비나 부족이 발생할 수 있음
- 예시


### 연결 리스트 기반 스택 (Linked List-based Stack)	
- 정의 : 연결 리스트를 이용하여 스택 자료 구조를 구현한 형태
- 특징
    -  연결 리스트를 사용하므로 동적 크기를 가짐
    -  연결 리스트의 헤드 노드가 Top 노드로 작동
- 장점
    -  연결 리스트를 사용하여 스택의 크기를 사전에 정할 필요가 없으며 유동적으로 확장 가능
    -  메모리의 낭비가 없음
    -  기타 자료구조로 확장이 용이함
- 단점
    -  각 노드에 포인터가 포함되어 있어 배열 기반 스택에 비해 메모리 사용량이 많음
    -  배열 기반 스택에 비해 구현이 복잡
    -  메모리가 연속적으로 할당되지 않아 배열 기반에 비해 캐시 성능이 떨어짐
    -  특정 위치에 있는 데이터를 참조하기 위해 Top부터 순차적으로 탐색해야해서 시간이 오래 걸림
- 예시


### 최소값/최대값 추적 스택 (Min/Max Stack)			
- 정의 : 스택 내에서 삽입과 삭제를 수행할 때 현재 스택의 최소값과 최대값을 추적할 수 있도록 설계된 스택
- 특징
    -  스택에 값을 삽입하거나 삭제할 때 스택 내의 최소값과 최대값을 추적함
    -  보조 스택을 사용하여 최소값과 최대값을 저장하여 조회가 빠름
- 장점
    -  최소값과 최대값을 **O(1)** 의 시간 복잡도로 조회 가능
- 단점
    -  최소값과 최대값을 추적하기 위해 보조 스택을 사용하여 메모리 사용량이 많음
    -  삽입, 삭제시 보조 스택도 관리해야 하므로 구현이 복잡
- 예시

---
## 큐 (Queue)
- 정의 : 한쪽 끝에서만 삽입이 이루어지고, 다른 한쪽 끝에서는 삭제가 이루어지는 FIFO 자료구조
- 특징
    -  앞(front)와 뒤(rear) 포인터를 가지고 삽입과 삭제 연산 수행
    -  주요 연산
       -  Enqueue - 데이터를 rear에 삽입
       -  Dequeue - 데이터를 front에서 삭제하고 반환
       -  peek - front에 있는 데이터를 반환
### 배열 기반 큐 (Array-based Queue)
- 정의 : 배열을 이용하여 큐를 구현하는 방식
- 특징
    -  배열을 이용하여 고정 크기를 가짐
    -  인덱스를 통해 데이터에 접근 가능
- 장점
    -  연속된 메모리 공간에 데이터를 저장해 접근이 빠름
- 단점
    -  크기가 정해져 있어 메모리 낭비 혹은 크기 초과 문제가 발생할 수 있음
    -  Dequeue를 반복할수록 front가 점점 뒤로 이동해 앞의 메모리 공간이 비어있는 상태로 방치될 수 있어 데이터 이동을 구현해야 함
- 예시


### 순환 큐 (Circular Queue)			
- 정의 : 배열 기반 큐에서 발생할 수 있는 메모리 낭비 문제를 해결하기 위해 원형 구조로 배열의 끝에 도달하면 다시 처음으로 돌아가 데이터를 삽입하거나 제거할 수 있도록 만든 큐
- 특징
    -  배열의 앞과 끝이 연결되어 배열의 끝에 도달하면 앞부터 다시 시작
- 장점
    -  Dequeue되어 빈 공간을 다시 사용할 수 있어 따로 데이터 이동을 구현할 필요가 없음
- 단점
    -  front와 rear가 배열의 끝에 도달하면 다시 앞으로 가게 만들어야 해서 배열 기반 큐에 비해 구현이 복잡
- 예시


### 연결 리스트 기반 큐 (Linked List-based Queue)			
- 정의 : 연결 리스트를 기반으로 큐를 구현하는 방식
- 특징
    -  연결 리스트 기반이기 때문에 큐의 크기를 동적으로 조정 가능
- 장점
    -  큐의 크기를 동적으로 조정 가능해 메모리 부족이나 낭비 문제가 해결됨
- 단점
    -  포인터 조작이 필요해 배열 기반 큐에 비해 연산 속도가 느림
    -  노드의 메모리 할당과 해제 비용이 계속해서 발생하고 메모리를 관리해야함
- 예시


### 우선순위 큐 (Priority Queue)			
- 정의 : 일반적인 큐와 달리 우선순위(priority)에 따라 데이터 처리 순서를 결정하는 큐
- 특징
    -  우선순위 값에 따라 큐 내부에서 데이터가 정렬됨
    -  우선순위가 높은 데이터부터 dequeue됨
    -  동일한 우선순위를 가지는 경우에는 FIFO를 따름


#### 배열 기반 우선순위 큐		
- 정의 : 배열을 사용하여 우선순위 큐를 구현한 형태
- 특징
    -  배열을 우선순위 순서 정렬 여부에 따라 두가지 방법으로 나뉨
    -  삽입과 삭제 연산의 효율성이 배열 정렬 여부에 따라 달라짐
- 장점
    -  배열을 기반으로 하기 때문에 구현이 간단
- 단점
    -  정렬되지 않은 배열 - dequeue시 우선순위를 찾는데 **O(n)** 의 시간이 필요
    -  정렬된 배열 - enqueue시 우선순위 정렬을 유지하기 위해 **O(n)** 의 시간이 필요
- 예시


#### 힙 기반 우선순위 큐
- 정의 : 힙 자료구조를 사용하여 우선순위 큐를 구현한 형태
- 특징
    -  이진 트리 형태를 가짐
    -  최대 힙(Max-Heap)의 경우에는 부모 노드의 우선순위 값이 자식 노드보다 크거나 같음
    -  최소 힙(Min-Heap)의 경우에는 부모 노드의 우선순위 값이 자식 노드보다 작거나 같음
- 장점
    -  euqueue와 dequeue 연산이 모두 **O(log n)** 의 시간 복잡도를 가져 효율적
    -  삽입과 삭제시 힙 재구성을 통해 정렬을 유지하여 추가 정렬 작업이 불필요
- 단점
    -  힙 자료구조를 기반으로 하기 때문에 구현이 복잡
    -  인덱스를 사용하지 않기 때문에 특정 요소에 직접 접근하는데 비효율적
- 예시



## 데크	(Deque, Double-Ended Queue)
- 정의 : 양쪽 끝에서 데이터 처리가 가능한 큐
- 특징
    -  삽입과 삭제 연산이 양쪽 끝에서 모두 가능
    -  큐와 스택의 성질을 포함하여 FIFO와 LIFO의 특성을 모두 가짐
  

### 배열 기반 데크 (Array-based Deque)			
- 정의 : 배열을 사용하여 데크를 구현한 형태
- 특징
    -  배열의 양 끝이 연결된 원형 구조(Circular Array)로 설계되어 배열 끝을 넘어가면 처음으로 돌아가서 빈 공간부터 연산
- 장점
    -  양쪽 끝에서의 삽입과 삭제 연산이 **O(1)** 으로 효율적
    -  원형 배열을 사용하기 때문에 고정된 메모리 내에서 효율적으로 동작
- 단점
    -  배열은 연속된 메모리 공간이 필요해 메모리 부족 상황에서 유언성이 떨어짐
- 예시



### 연결 리스트 기반 데크 (Linked List-based Deque)			
- 정의 : 이중 연결 리스트를 사용하여 데크를 구현한 형태
- 특징
    -  이중 연결 리스트 기반이기 때문에 크기를 미리 설정하지 않아도 됨
    -  배열 기반 데크보다 구조적으로 유연하고 크기 제한이 없음
- 장점
    -  필요할 때만 메모리를 동적으로 할당하여 메모리 낭비를 줄일 수 있음
    -  양쪽 끝에서의 삽입과 삭제가 **O(1)** 으로 효율적
- 단점
    -  각 노드가 데이터와 포인터를 저장해야하므로 배열 기반 데크에 비해 메모리 공간이 많이 필요함
    -  특정 인덱스의 데이터에 접근하려면 순차 탐색이 필요하여 **O(n)** 의 시간 복잡도가 필요함
- 예시

--- 
## 트리				
### 일반 트리 (Tree)		
- 정의 : 계층적(hierarchical) 구조를 표현하기 위한 비선형 자료구조
- 특징	
    -  노드(Node)와 간선(Edge)로 구성되어 노드들 간의 계층적인 관계(부모-자식 관계)를 나타냄
    -  하나의 루트 노드에서 시작하며, 모든 노드는 루트 노드와 연결되어 있어야 함
- 주요 용어
    -  루트 노드(Root Node) - 트리의 최상위 노드, 부모 노드가 존재하지 않는 유일한 노드
    -  부모 노드(Parent Node) - 자식 노드와 연결된 상위 노드
    -  자식 노드(Child Node) - 부모 노드와 연결된 하위 노드
    -  형제 노드(Sibling Node) - 동일한 부모 노드를 가지는 노드
    -  리프 노드(Leaf Node) - 자식 노드가 없는 노드
    -  깊이(Depth) - 루트 노드에서 특정 노드까지의 경로 길이
    -  높이(Height) - 특정 노드에서 리프 노드까지의 최대 경로 길이
    -  서브트리(Subtree) - 트리의 특정 노드를 루트 노드로 하는 부분 트리
    -  차수(Degree) - 노드가 가지는 자식 노드의 개수
- 장점
    -  각 노드가 자식 노드의 수에 제한일 받지 않아 다양한 데이터 표현 가능
    -  서브트리도 트리의 성질을 가져 재귀적 알고리즘을 쉽게 적용할 수 있음
- 단점
    -  각 노드가 여러 자식 노드를 가질 수 있어 구현이 복잡해질 수 있음
    -  특정 노드를 찾으려면 순회가 필요해 **O(n)** 의 시간 복잡도를 가짐
    -  자식 노드의 수가 동적이라 이진 트리 등에 비해 알고리즘이 제한적임
- 예시


### Left-child-right-sibling(LCRS) 트리		
- 정의 : 일반 트리를 이진 트리로 변환한 형태의 트리
- 특징
    -  각 노드의 첫번째 자식 노드를 왼쪽 포인터로 가리키고, 형제 노드를 오른쪽 포인터로 가리킴
    -  일반 트리를 이진 트리의 형태로 변환했기 때문에 이진 트리의 알고리즘을 사용할 수 있음
- 장점
    -  일반 트리에 비해 각 노드가 두 개의 포인터만 사용하기 때문에 메모리 사용량이 적음
    -  자식 노드와 형제 노드를 분리하여 트리 관리가 비교적 간단
- 단점
    -  형제 노드 간의 탐색이 오른쪽 포인터를 따라가야 해 형제 노드가 많을 경우 비효율적임
    -  계층을 표현하기 위해 자식 노드와 형제 노드간의 관계를 재귀적으로 순회해야 함
    -  특정 위치에 노드를 삽입하거나 삭제할 때, 포인터 재조정이 필요하여 연산이 복잡해질 수 있음
- 예시


### 트리 순회
- 정의 : 트리 구조의 모든 노드를 일정한 규칙에 따라 탐색하는 방법
- 특징
    -  트리의 모든 노드를 순회하여 데이터를 처리함
    -  트리 구조의 재귀적 특성 때문에 대부분의 순회 알고리즘이 재귀적으로 구현
    -  깊이 우선 탐색(DFS)와 너비 우선 탐색(BFS)의 방법으로 나뉨
#### 전위 순회 (Pre-order Traversal)
- 정의 : 루트 노드를 먼저 방문한 후 왼쪽 서브트리와 오른쪽 서브트리를 순서대로 탐색하는 방법
- 특징
    -  루트 노드가 서브트리보다 우선적으로 처리됨
    -  재귀적으로 정의되어 각 서브트리에도 동일한 방식으로 진행됨
    -  깊이 우선 탐색 방식으로 노드의 깊이를 따라 탐색
- 장점
    -  노드를 루트에서부터 순차적으로 처리하기 때문에 트리의 구조를 복사하거나 재구성하는데 유용
    -  루트가 항성 먼저 탐색되므로 계층적 데이터 구조의 루트 우선 순서를 유지
- 단점
    -  계층 구조는 드러나지만 데이터의 정렬된 순서를 보장하지 않음
- 예시


#### 중위 순회 (In-order Traversal)		
- 정의 : 왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리 순서대로 탐색하는 방법
- 특징
    -  이진 탐색 트리에서 데이터가 오름차순으로 정렬된 결과를 보임
- 장점
    -  이진 탐색 트리에서 탐색 결과가 데이터들이 오름차순으로 졍렬된 결과와 같음
- 단점
    -  이진 트리를 기반으로 하므로 일반 트리에서는 적용하기 어려움
- 예시


#### 후위 순회 (Post-order Traversal)		
- 정의 : 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트 순서대로 탐색하는 방법
- 특징
    -  모든 자식 노드를 방문한 후에 부모 노드를 처리
- 장점
    -  자식 노드를 모두 처리한 후 부모 노드를 처리하기 때문에 종속 관계의 데이터 처리에 적합
- 단점
    -  루트 노드를 마지막에 처리하므로 루트 노드에 대한 즉각적인 작업이 불가능
    -  루트 중심의 탐색이 아니기 때문에 계층적 구조 파악이 어려울 수 있음
- 예시


#### 레벨 순회 (Level-order Traversal)		
- 정의 : 루트 노드에서 시작하여 같은 레벨의 노드들을 왼쪽에서 오른쪽 순서대로 탐색하는 방법
- 특징
    -  한 레벨씩 내려가며 같은 레벨의 노드를 왼쪽에서 오른쪽 순서로 탐색
- 장점
    -  트리의 계층 구조를 그대로 탐색하여 직관적으로 이해하거나 시각화하는데 유용
    -  BFS방식이므로 최단 경로 탐색에 적합
- 단점
    -  큐를 사용해야해 트리의 최대 너비만큼 추가적인 메모리 공간이 필요
    -  깊은 노드의 탐색 시간이 오래 걸리고 비효율적
- 예시


### 이진 트리 (Binary Tree)			
- 정의 : 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 구조
- 특징
    -  각 노드가 최대 두 개의 자식 노드(왼쪽, 오른쪽)을 가질 수 있음
    -  왼쪽과 오른쪽 서브트리가 각각 또 다른 이진 트리로 구성되는 재귀적 성질을 가짐


#### 포화 이진 트리 (Full Binary Tree)		
- 정의 : 모든 레벨이 완전히 채워져 있는 이진 트리
- 특징
    -  리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가짐
    -  모든 리프 노드가 동일한 레벨을 가짐
    -  높이가 $h$ 인 트리의 전체 노드 개수는 $2^h-1$개 이고, 리프 노드의 개수는 $2^{h-1}$개이다
- 장점
    -  주어진 높이에서 노드가 최대로 채워져 있어 공간 사용이 효율적
    -  트리의 높이가 최소화되어 탐색, 삽입, 삭제 연산의 시간 복잡도가 **O($log\,n$)** 으로 효율적
- 단점
    -  구조를 유지하기 위해 삽입, 삭제 연산시 재구성이 필요하고 제한적임
    -  데이터의 개수가 $2^h-1$개가 아닌 경우 포화 이진 트리 구조를 적용하기 어려움
- 예시


#### 완전 이진 트리 (Complete Binary Tree)		
- 정의 : 마지막 레벨을 제외한 모든 레벨이 완전히 채워져있으며, 마지막 레벨은 왼쪽부터 순차적으로 노드가 채워진 이진 트리
- 특징
    - 리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가짐
    -  배열로 쉽게 구현이 가능하며, 부모 노드와 자식 노드 간의 인덱스 관계가 명확하여 포인터를 사용하지 않아도 됨
- 장점
    -  트리의 높이가 최소화되어 탐색, 삽입, 삭제 연산의 시간 복잡도가 O($log\,n$) 으로 효율적
    -  포인터를 사용하지 않고 배열 인덱스를 통해 부모-자식 관계를 관리할 수 있어 메모리 사용이 효율적
    -  노드를 추가하거나 삭제할 때 트리의 균형을 유지하기 쉽고, 연산이 효율적
- 단점
    -  트리의 구조가 특정 패턴을 따라 임의의 위치에 노드를 삽입하거나 삭제하는것이 제한적임
    -  배열을 이용하기 때문에 메모리 사용량 관리를 해줘야 함
- 예시


#### 경사 트리 (Skewed Tree)		
- 정의 : 트리의 모든 노드가 같은 방향의 자식 노드만을 가지는 편향된 구조의 트리
- 특징
    -  모든 노드가 하나의 자식 노드만을 가지며 같은 방향의 자식 노드임
    -  트리의 높이($h$)와 트리의 노드 개수($n$)가 동일함($h = n$) 
    -  사실상 일렬로 연결된 노드들의 집합
- 장점
    -  트리의 구조가 단순하여 구현이 용이
    -  노드가 한쪽 자식만을 가지므로 메모리 할당 및 관리가 단순
- 단점
    -  트리가 편향되어 있고, 트리의 높이가 $n$이므로, 탐색, 삽입, 삭제 연산의 시간 복잡도가 $O(n)$으로 비효율적
    -  균형 잡힌 트리 구조가 아니기 때문에, 알고리즘 등이 제한적임
- 예시


#### 수식 트리 (Expression Tree)		
- 정의 : 수학적 또는 논리적 수식을 트리 구조로 표현한 형태
- 특징
    -  리프 노드는 피연산자(숫자, 변수 등)를 나타내고, 그 이외 노드는 연산자를 나타냄
    -  대부분의 수식 트리는 이진 트리로 구현되어 각 연산자가 두 개의 피연산자를 가지나, 단항 연산자의 경우 하나의 자식 노드만을 가질 수도 있음
    -  순회 방법에 따라 수식 표기법이 다른 결과가 나옴
       - 전위 순회 - 수식을 전위 표기법으로 변환
       - 중위 순회 - 수식을 일반적인 수식 형태로 변환
       - 후위 순회 - 수식을 후위 표기법으로 변환
- 장점
    -  후위 순회를 이용한 수식 평가가 가능하여 스택을 이용하여 효율적 계산 가능
- 단점
    -  특정 수식 구조에서 트리가 편향되어 높이가 증가하여 순회 및 평가 성능에 영향을 미칠 수 있음
- 예시


### 이진 탐색 트리 (Binary Search Tree)			
- 정의 : 각 노드가 최대 두 개의 자식 노드를 가지고, 왼쪽 서브트리의 모든 노드 값은 현재 노드의 값보다 작고, 오른쪽 서브트리의 모든 노드 값은 현재 노드의 값보다 큰 이진 트리
- 특징
    -  트리의 왼쪽 서브트리는 현재 노드보다 작은 값을 가지고, 오른쪽 서브트리는 큰 값을 가져 중위순회를 수행하면 오름차순으로 정렬된 값을 얻을 수 있음
    -  일반적으로 중복된 값을 허용하지 않아 각 노드의 값은 고유해야 함
#### 균형 이진 탐색 트리 (Balanced BST)		
- 정의 : 트리의 높이를 최소화하여 균형을 유지하는 이진 트리
- 특징
    -  트리의 각 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 특정 기준 이하로 유지됨
    -  각 서브트리도 균형 이진 탐색 트리의 특성을 만족하는 재귀적 특성을 만족함
    -  균형이 유지되어 트리의 높이가 $O(log\,n)$으로 제한됨
- 장점
    -  트리의 높이가 제한되어 있어 검색, 삽입, 삭제 연산을 효율적으로 수행 가능
    -  균형을 유지함으로써 $O(log\,n)$의 성능을 보장
    -  중위 순회를 통해 데이터를 오름차순으로 쉽게 접근할 수 있음
- 단점
    -  노드 삽입이나 삭제 시 균형을 유지하기 위해 회전 연산을 수행해야 함
- 예시


##### AVL 트리 (AVL Tree)	
- 정의 : 균형 이진 탐색 트리의 한 종류로, 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1 이하로 유지되도록 설계
- 특징
    -  $(왼쪽 서브트리의 높이) - (오른쪽 서브트리의 높이)$를 균형 인수라고 하며 $-1\leq n \leq 1\,(n은 정수)$를 만족해야함
    -  균형 인수가 범위를 벗어난 경우, 트리가 불균형 상태이므로 회전 연산을 통해 균형을 회복해야함
- 장점
    -  트리의 균형이 항상 유지되므로, 모든 연산에서 일관된 성능 보장
- 단점
    -  회전 연산을 구현해야해 구현의 복잡성이 증가
    -  각 노드가 자신의 높이 정보를 저장해야해 메모리 사용량이 많음
    -  특정 삽입, 삭제 패턴에서 트리의 균형을 유지하기 위한 연산이 빈번하게 발생할 수 있어 성능 최적화가 어려울 수 있음
- 예시


##### 레드-블랙 트리 (Red-Black Tree)	
- 정의 : 각 노드에 색상을 부여하여 자체적으로 트리의 균형을 유지하는 특성을 가진 이진 트리
- 특징
    -  각 노드는 레드 또는 블랙 색상을 가지며, 루트 노드와 모든 리프 노드는 항상 블랙
    -  레드 노드는 자식 노드가 모두 블랙이어야 함
    -  모든 경로에서 루트 노드부터 리프 노드까지의 블랙 노드 수가 동일해야함
- 장점
    -  탐색, 삽입, 삭제 연산이 모두 O($log\,n$) 시간 복잡도로 수행
    -  AVL트리에 비해 삽입과 삭제 시 회전 횟수가 적어 메모라 사용과 연산이 효율적
- 단점
    -  색상 규칙과 균형 유지를 위한 회전 연산을 구현하는것이 복잡
    -  각 노드가 색상 정보를 저장해야 해, 메모리 사용량이 비교적 높음
- 예시


##### Splay Tree	
- 정의 : 최근에 접근한 노드를 트리의 루트 노드로 이동시키는 Splay 연산을 통해 트리의 구조를 조정하는 이진 탐색 트리
- 특징
    -  Splay 연산을 통해 최근에 접근한 노드들이 루트 노드 근처에 위치해 있어 더 빠르게 탐색할 수 있음
    -  특정 회전 패턴을 사용하여 Splay 연산을 수행
       -  zig step - 대상 노드가 부모 노드만 가지고 있는 경우(조부모 노드가 없을 때)
       -  zig-zig step - 대상 노드와 부모 노드가 둘다 왼쪽 혹은 오른쪽 자식 노드인 경우
       -  zig-zag step - 대상 노드와 부모 노드가 서로 다른 방향의 자식 노드인 경우
    -  별도의 균형 인수를 유지하지 않고도, Splay연산을 통해 트리의 균형을 간접적으로 유지
- 장점
    -  별도의 균형 정보나 노드의 추가적인 속성을 저장할 필요가 없어 비교적 단순한 구조를 지님
    -  최근에 접근한 노드가 루트에 위치하게 되어, 접근 패턴이 국소적일 경우 높은 효율성을 띔
- 단점
    -  항상 가장 깊은 노드를 반복적으로 접근하면 트리가 편향되고 효율이 떨어짐
    -  회전 연산과 Splay 연산을 효율적으로 수행하기 위한 구현에 난이도가 있음
- 예시


#### B 트리 계열		
##### B 트리 (B-Tree)	
- 정의 : 다수의 자식을 가질 수 있는 균형 잡힌 트리 구조
- 특징
    -  다중 경로 트리의 일종으로, 각 노드가 여러 개의 키와 자식 포인터를 가질 수 있음
    -  각 노드는 최소 t-1개, 최대 2t-1개의 키를 가질 수 있고, 이에 따라 최소 t개, 최대 2t개의 자식 노드를 가질 수 있음(t는 트리의 차수).
    -  모든 리프 노드가 같은 깊이에 위치하여 트리의 균형을 유지
    -  각 노드 내의 키는 오름차순으로 정렬되어 있음
- 장점
    -  트리의 높이가 낮아 모든 기본 연산이 O($log\,n$) 시간 복잡도로 수행
    -  각 노드가 여러 키와 포인터를 포함하여 디스크 블록 하나에 많은 정보를 저장할 수 있어 디스크 I/O 횟수를 줄일 수 있음
    -  키가 정렬되어 있어 특정 범위 내의 키들을 효율적으로 검색 가능
- 단점
    -  각 노드가 여러 개의 키와 포인터를 저장해야 해, 메모리 사용량이 증가할 수 있음
    -  트리의 차수 t의 적절한 값 설정이 어렵고, 잘못된 차수 설정은 트리의 성능에 부정적인 영향을 미침
- 예시
##### B+ 트리 (B+ Tree)	
- 정의 : 모든 실제 데이터가 리프 노드에만 저장되고, 내부 노드는 인덱스 영할을 하는 키만을 저장하는 B 트리의 변형
- 특징
    -  내부 노드는 키와 자식 포인터만을 저장하고, 실제 데이터는 리프 노드에만 저장됨
    -  리프 노드들이 연결 리스트 형태로 연결되어 있음
- 장점
    -  리프 노드들이 연결 리스트 형태로 연결되어 있어 연속적인 데이터 접근이 빠름
    -  실제 데이터가 리프 노드에만 저장되어 키 중복이 발생하지 않고, 캐시 효율성이 좋음
- 단점
    -  리프 노드의 연결과 내부 노드의 키 관리 등을 구현해야 해서 구현이 복잡
    -  삽입과 삭제 시 노드의 분할과 병합이 발생할 수 있으며, 병합 과정에서 부모 노드의 키 재배치가 필요해 B 트리보다 복잡하고 시간이 오래 걸림
- 예시


##### B* 트리 (B* Tree)	
- 정의 : 노드의 공간 활용률을 높이기 위해 더 밀집된 키 배치를 사용하는 B 트리의 변형
- 특징
    -  노드의 추가적인 생성과 추가적인 연산의 최소화를 위해 B 트리에서 몇 가지 규칙이 추가된 형태
    -  노드가 가득 차면 분열 대신 이웃한 형제 노드로 재배치
- 장점
  - 각 노드가 여러 키와 포인터를 저장해 디스크 블록 하나에 많은 정보를 저장할 수 있어 디스크 I/O 횟수를 줄일 수 있음
  - 노드가 꽉 차면 단순히 분할하지 않고 병합하므로, 트리가 더욱 균형 있게 유지됨
- 단점:
  - 노드 분할 및 병합 방식이 복잡하여 구현이 어려움
- 예시


### 힙 (Heap)	
- 정의 : 완전 이진 트리의 일종으로, 부모 노드와 자식 노드 간의 특정한 관계를 만족하는 자료구조
- 특징
    -  주로 우선순위 큐를 구현하는데 사용
    -  부모 노드는 자식 노드보다 우선순위가 높다는 특성을 가짐
  

#### 최대 힙 (Max-Heap)		
- 정의 : 부모 노드의 값이 자식 노드의 값보다 크거나 같다는 특성을 가진 힙
- 특징
    -  부모 노드의 값이 자식 노드의 값보다 크거나 같아야 하므로(Heapify) 루트 노드에는 항상 최대값이 위치
- 장점
    -  루트 노드에 최대값이 항상 위치하여 최대값을 $O(1)$ 시간 복잡도에 접근 가능
- 단점
    -  최대값 접근에는 최적화되어 있지만, 임의의 요소 검색에는 $O(n)$ 시간 복잡도를 가져 비효율적
- 예시


#### 최소 힙 (Min-Heap)		
- 정의 : 부모 노드의 값이 자식 노드의 값보다 작거나 같다는 특성을 가진 힙
- 특징
    -  부모 노드의 값이 자식 노드의 값보다 작거나 같아야 하므로(Heapify) 루트 노드에는 항상 최소값이 위치
- 장점
    -  루트 노드에 최소값이 항상 위치하여 최대값을 $O(1)$ 시간 복잡도에 접근 가능
- 단점
    -  최소값 접근에는 최적화되어 있지만, 임의의 요소 검색에는 $O(n)$ 시간 복잡도를 가져 비효율적
- 예시


#### 피보나치 힙 (Fibonacci Heap)		
- 정의 : 피보나치 수열과 유사한 구조적 특성을 가진 자료구조
- 특징
    -  최소 힙 속성을 만족함
    -  여러 개의 트리로 구성되어 루트 노드들이 이중 연결 리스트 형태로 연결되어있고, 트리 간에는 순서 관계가 없음
    -  lazy 구조를 채택하여 트리의 재구성이 연산시 바로 일어나는 것이 아니라, 실제 필요할때 재구성시킴
- 장점
    -  대부분의 연산시 상수 시간에 수행되고, 삭제 연산만이 $O(log\,n)$ 시간 복잡도를 가져 매우 효율적임
    -  다중 루트 트리 구조 덕분에 병합 연산을 $O(1)$에 수행 가능
    -  lazy구조로 불필요한 작업을 줄일 수 있음
- 단점
    -  노드 분할, 병합, 마크 비트 관리 등 연산 구현이 매우 복잡
    -  실제 응용에서는 상수 계수가 높아 다른 힙 자료 구조들에 비해 느릴 수 있음
- 예시


### 분리 집합 (Disjoint Set)	
- 정의 : 여러 개의 원소들을 서로 겹치지 않는 집합을 통해 관리하는 자료구조
- 특징
    -  모든 원소는 정확히 하나의 집합에만 속하고, 집합 간에는 겹침이 없음
    -  각 집합은 트리 구조로 표현되고, 루트 노드는 해당 집합의 대표 원소를 의미
- 주요 연산
    -  합병(Union) - 집합을 합침
    -  찾기(Find) - 특정 원소가 집합 찾기
#### Union-Find 알고리즘		
- 정의 : 분리 집합을 관리하고 합병과 찾기 연산을 수행하는 알고리즘
- 특징
    -  각 집합은 트리 구조로 표현되고, 루트 노드는 해당 집합의 대표 원소 역할을 함
    -  Find 연산 시 트리의 경로 압축 최적화를 진행함
    -  Union 연산 시 두 트리의 높이와 크기를 비교하여 작은 트리를 큰 트리의 자식으로 연결
- 장점
    -  Find와 Union 연산이 거의 상수 시간에 수행되어 대규모 데이터에서도 빠르게 데이터를 관리 가능
    -  랭크 기반 합병과 경로 압축을 통해 트리의 높이를 낮게 유지하여 연산의 효율성을 극대화함
- 단점
    -  초기 원소 집합이 고정되어 있어 원소를 추가하거나 제거하는 데 한계가 있음
    -  병렬 처리가 어려워 병렬 알고리즘에서 사용하기에 제한적
- 예시


#### 경로 압축 및 크기 조정	(Path Compression and Union by Size)
- 정의 : Union-Find 알고리즘에서 연산을 최적화하기 위한 기법
- 경로 압축
    -  정의 : Find 연산을 수행할 때, 트리의 각 노드들을 루트 노드에 직접 연결함으로써 트리의 높이를 줄이는 기법
    -  특징
       -  Find 연산을 수행할 때마다 트리의 경로를 단축시켜 높이를 줄여 이후 Find 연산이 더 빠르게 수행됨
- 크기 조정
    -  정의 : Union 연산을 수행할 때, 작은 트리를 큰 트리의 자식으로 연결하여 트리의 높이를 최소화하는 기법
    -  특징
       -  작은 집합을 큰 집합에 합침으로써 트리의 높이가 지나치게 증가하는것을 방지
- 예시


## 그래프				
### 그래프 (Graph)	
- 정의:
- 특징:		
#### 방향 그래프 (Directed Graph)		
- 정의 : 
- 특징
- 장점
- 단점
- 예시
#### 무방향 그래프 (Undirected Graph)		
#### 가중 그래프 (Weighted Graph)		
#### 비가중 그래프 (Unweighted Graph)		
### 그래프 표현 방식			
- 정의:
- 특징:
#### 인접 행렬 (Adjacency Matrix)		
#### 인접 리스트 (Adjacency List)		
### 그래프 순회			
- 정의:
- 특징:
#### 너비 우선 탐색 (Breadth-First Search, BFS)		
#### 깊이 우선 탐색 (Depth-First Search, DFS)		
### 최단 경로 알고리즘		
- 정의:
- 특징:	
#### 다익스트라 알고리즘 (Dijkstra's Algorithm)		
#### 벨만-포드 알고리즘 (Bellman-Ford Algorithm)		
#### 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)		
### 최소 신장 트리 (Minimum Spanning Tree)		
- 정의:
- 특징:	
#### 크루스칼 알고리즘 (Kruskal's Algorithm)		
#### 프림 알고리즘 (Prim's Algorithm)		
### 위상 정렬 (Topological Sorting)			
- 정의:
- 특징:
### 강결합 요소 탐색 (Strongly Connected Components)			
- 정의:
- 특징:
### 이분 그래프 탐색 (Bipartite Graph Check)			
- 정의:
- 특징:
## 해시
- 정의:
- 특징:				
### 해시 테이블 (Hash Table)			
### 해시 함수 (Hash Function)			
### 충돌 처리 (Collision Handling)			
#### 개방 주소법 (Open Addressing)		
#### 체이닝 (Chaining)		
### 동적 크기 조정 (Dynamic Resizing)			
### 블룸 필터 (Bloom Filter)			