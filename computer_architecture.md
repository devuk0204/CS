## 컴퓨터구조와 개요 (Introduction to Computer Architecture)		
### 컴퓨터 구조란 무엇인가?	
-  컴퓨터 시스템의 기능, 조직, 구현에 대한 법칙과 방법
-  컴퓨터 시스템의 구성 요소와 그들 간의 상호 작용을 설명하는 개념으로, 하드웨어와 소프트웨어의 상호 작용을 포함
### 컴퓨터 시스템의 발전과 역사	
역사
### 컴퓨터의 구성 요소 (Components of a Computer System)
#### 중앙처리장치(CPU) [바로가기](#중앙처리장치-cpu-central-processing-unit)
-  컴퓨터 시스템에서 명령어를 해석하고 실행하는 장치
-  데이터의 처리와 제어 흐름을 담당
#### 메모리(Memory) [바로가기](#메모리-구조-memory-architecture)
- 정의
    -  컴퓨터 시스템 내에서 데이터와 명령어를 저장하고, 필요할 때 접근할 수 있도록 하는 하드웨어 장치
    -  주기억장치(Primary memory)와 보조기억장치(Secondary Storage)로 구분된다
- 종류
    -  주기억장치
       -  ROM(Read Only Memory) - 컴퓨터 전원이 끊어져도 기록된 데이터들이 소멸하지 않는 비휘발성 메모리로, BIOS와 같은 주요 데이터를 저장한다
       -  RAM(Random Access Memory) - 전원이 끊어지면 기록된 데이터들이 소멸하는 휘발성 메모리이며, 읽고 쓰기가 가능함 
    -  보조기억장치
       -  HDD(Hard Disk Drive) - 자기 디스크를 사용해 데이터를 저장하는 장치, 회전하는 플래터와 읽기/쓰기 헤더를 이용함
       -  SDD(Solid State Drive) - 반도체를 이용하여 데이터를 저장하는 장치, 플래시 메모리를 사용하고, HDD와 비교해 작교 가벼우며 처리 속도가 빠름
       -  USB(Universal Serial Bus) - USB 포트에 꽂아 사용하는 이동형 저장장치, 플래시 메모리를 사용함
#### 입출력 장치 (I/O Devices) [바로가기](#입출력-시스템-io-systems)
- 정의
    -  컴퓨터 시스템과 외부 환경 간의 데이터 교환을 가능하게 하는 하드웨어 장치
- 종류
    -  입력장치 - 키보드, 마우스, 터치스크린, 스캐너 등
    -  출력장치 - 모니터, 프린터, 스피커 등
    -  입출력장치 - 터치스크린, 모뎀, 네트워크 카드, 외장 하드 등
### 폰노이만 아키텍처 (Von Neumann Architecture) vs. 하버드 아키텍처 (Harvard Architecture)	
- 폰 노이만 아키텍처
    -  프로그램과 데이터를 동일한 메모리에 저장하고, CPU가 메모리에서 명령어를 순차적으로 가져와 실행하는 컴퓨터 설계 모델
    -  구성 요소 - CPU, Memory, I/O Devices, Bus
    -  특징
       -   프로그램과 데이터를 동일한 메모리에 저장함으로써, 프로그램의 수정과 데이터의 접근이 용이
       -   명령어를 순차적으로 처리함으로써, 프로그램의 흐름을 예측 가능하게 함
    -  구조
        ![폰 노이만 아키텍처](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/250px-Von_Neumann_Architecture.svg.png)   
        Image source : https://commons.wikimedia.org/wiki/File:Von_Neumann_Architecture.svg

- 하버드 아키텍처
    -  명령어와 데이터를 별도의 메모리 공간에 저장하고, 독립적인 버스를 통해 접근하는 컴퓨터 설계 모델
    -  구성 요소 - CPU, Instruction Memory, Data Memory, I/O Devices, Instruction Bus, Data Bus
    -  특징
       -  명령어와 데이터를 별도의 메모리 공간에 저장함으로써, 두 공간에 동시에 접근하고 처리 가능하여 처리 속도가 빠름
       -  명령어 버스와 데이터 버스가 분리되어 있어, 병목 현상이 줄어들고, 데이터 전송의 병렬성이 확보되어 고속 데이터 처리와 실시간 연산이 요구되는 시스템에 유리
    -  구조
        ![하버드 아키텍처](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Harvard_architecture.svg/220px-Harvard_architecture.svg.png)   
        Image source : https://commons.wikimedia.org/wiki/File:Harvard_architecture.svg
- 폰 노이만 아키텍처와 하버드 아키텍처의 차이점
    -  메모리에 접근하는 법이 다름
    -  폰 노이만 아키텍처는 하나의 메모리에 명령어와 데이터를 저장해두고 접근하는 반면, 하버드 아키텍처는 명령어 메모리와 데이터 메모리를 따로 두고, 병렬 접근 가능

### 컴퓨터 설계의 기본 원리 (Fundamental Principles of Computer Design)	

--- 	
## 명령어 집합 구조(ISA, Instruction Set Architecture)		
-  주어진 아키텍처가 실행할 수 있는 명령어들의 집합과 그 명령어들의 형식, 동작 빙식, 주소 지정 방식 등을 포함하는 설계 규칙
-  하드웨어와 소프트웨어 사이의 인터페이스
### CISC (Complex Instruction Set Computer)	
- 정의
    -  복잡하고 다양한 명령어를 포함하는 명령어 집합 구조를 가진 컴퓨터 아키텍처
- 특징
    -  가변 길이 명령어를 가질 수 있어 명령어의 복잡성과 다양성을 증가시킴, 이를 통해 더 많은 기능을 하나의 명령어로 구현
    -  다양한 주소 지정 방식을 지원하여 데이터 접근 방법의 유언성을 제공하고, 복잡한 데이터 구조를 쉽게 처리 가능함
- 장점 
    -  복잡한 명령어를 사용하여 작업을 수행하는데 필요한 명령어 수가 줄어들어 코드의 밀도가 높아질 수 있음
    -  많은 기능을 하나의 명령어로 구현할 수 있어, 하드웨어의 복잡성을 숨기고 추상화된 인터페이스를 제공할 수 있음
- 단점
    -  복잡한 명령어 집합과 마이크로코드의 사용으로 CPU설계가 복잡해짐
    -  명렁어가 복잡하고 길이가 가변적이기 때문에, 효율적인 파이프라이닝을 구현하기 어려움
    -  하드웨어가 복잡한 명령어를 처리해야 하기 때문에, RISC에 비해 명령어의 실행 속도가 느림
-  예시
    -  Intel x86 아키텍처 CPU, AMD x86 호환 CPU, 모토로라 68000 시리즈, IBM 메인프레임 CPU 등
### RISC (Reduced Instruction Set Computer)	
- 정의
    -  단순하고, 고속의 명령어 집합을 사용하는 컴퓨터 아키텍처
- 특징
    -  명령어의 복잡성을 줄여 단순한 구조로 설계되고, 명령어 길이가 고정되어 있음
    -  레지스터를 적극적으로 사용하여 메모리 접근을 최소화함
    -  데이터 메모리에 접근하는 명령어(로드/스토어)와 데이터 레지스터간의 연산을 분리하여 처리
- 장점
    -  단순하고 고정된 명령어 구조로, 파이프라이닝을 효과적으로 구현할 수 있음
    -  복잡한 명령어 처리가 필요 없기 때문에, 전력 소비가 적고, 에너지 효율성이 높아 모바일 및 임베디드 시스템에 적합
- 단점
    -  하나의 복잡한 명령어를 여러 단순한 명령어로 구현해야 하기 때문에, 전체 명령어 수가 증가하여 코드의 길이가 길어질 수 있음
    -  데이터 메모리에 접근하는 명령어가 별도로 존재하기 때문에, 복잡한 메모리 연산을 직접 지원하지 않음
    -  많은 레지스터를 필요로 해서 하드웨어 설계가 복잡하고, 레지스터 수가 제한적일 경우 성능 저하로 이어질 수 있음
- 예시
    -  Apple A시리즈 칩, Qualcomm Snapdragon 시리즈, AWS Graviton 프로세서 등
--- 
## 데이터 표현 및 연산 (Data Representation and Operations)		
### 수의 체계 (Number Systems)
- 컴퓨터는 우리가 흔히 일생상활에서 사용하는 10진수가 아닌, 2진수, 8진수와 16진수를 사용
- 컴퓨터는 전자 신호의 ON(1)과 OFF(0) 상태를 기반으로 작동하기 때문에 2진법 기반의 숫자 체계를 사용
#### 2진수(Binary), 8진수(Octal), 16진수(Hexadecimal) 표현
- 2진수
    -  0과 1 두 가지 숫자만을 사용하여 수를 표현하는 체계
    -  각 자릿수가 하나의 bit이며, 2의 거듭제곱수를 나타냄
    -  $n$개 자릿수를 가진 이진수라면 $2^0$부터 시작하여 $2^{n-1}$까지가 각 자릿수에 대응
    -  예시
       -  2진수 $1001$을 10진수로 변환하면 $1*2^3 + 0*2^2 + 0*2^1 + 1*2^0$으로 $9$
       -  10진수 $7$을 2진수로 변환하면 $1*2^2 + 1*2^1 + 1*2^0$이므로 $111$
- 8진수
    -  0부터 7까지 8개의 숫자를 사용하여 수를 표현하는 체계
    -  8진수 한 자릿수가 2진수 3bit와 대응하며, 8의 거듭제곱수를 나타냄
    -  $n$개 자릿수를 가진 8진수라면 $8^0$부터 시작하여 $8^{n-1}$까지가 각 자릿수에 대응
    -  예시
       -  8진수 $101$을 10진수로 변환하면 $1*8^2 + 0*8^1 + 1*8^0$으로 $65$
       -  10진수 $18$을 8진수로 변환하면 $2*8^1 + 2*8^0$이므로 $22$
- 16진수
    -  0부터 9까지와 A부터 F(A : 10 ~ F : 15)까지 6개의 문자, 총 16개의 숫자로 수를 표현하는 체계
    -  각 자릿수가 2진수 4bit에 대응하며, 16의 거듭제곱수를 나타냄
    -  $n$개 자릿수를 가진 16진수라면 $16^0$부터 시작하여 $16^{n-1}$까지가 각 자릿수에 대응
    -  예시
       -  16진수 FA를 10진수로 변환하면 $F(15)*16^1 + A(10)*16^0$으로 $250$
       -  10진수 $720$를 16진수로 변환하면 $2*16^2 + D(13)*16^1 + 0*16^0$이므로 $2D0$
#### 체계 간 변환
- 2진수 - 8진수 변환
    - 8진수의 한 자리가 2진수의 3bit에 대응하므로 2진수를 오른쪽부터 세자리씩 끊어서 8진수로 변환한 후 순서대로 결합
    - 8진수를 2진수로 변환할때는 8진수 한 자리를 2진수 3bit로 변환한 후 순서대로 결합
    - 예시
      -  2진수 $1 101 011$을 8진수로 변환하면 $001 | 101 | 011$ -> $1 | 5 | 3$ 이므로 $153$
      -  8진수 $161$을 2진수로 변환하면 $1 | 6 | 1$ -> $001 | 110 | 001$ 이므로 $1110001$
- 2진수 - 16진수 변환
    - 16진수의 한 자리가 2진수의 4bit에 대응하므로 2진수를 오른쪽부터 네자리씩 끊어서 16진수로 변환한 후 순서대로 결합
    - 16진수를 2진수로 변환할때는 16진수 한 자리를 2진수 4bit로 변환한 후 순서대로 결합
    - 예시
      -  2진수 $111 0010 1001$을 16진수로 변환하면 $0111|0010|1001$ -> $7|2|9$이므로 $729$
      -  16진수 $C A 8$을 2진수로 변환하면 $C|A|8$ -> $1101|1010|1000$이므로 $110110101000$
- 8진수 - 16진수 변환
      - 8진수에서 16진수로 변환할때는, 8진수를 2진수로 변환 후 16진수로 변환
      - 16진수를 8진수로 변환할때는, 16진수를 2진수로 변환 후 8진수로 변환
### Signed vs. Unsigned 데이터	
- 컴퓨터에서 정수를 표현하는 방법으로 부호의 유무에 따라 사용
- Signed
  - 양수와 음수 둘 다 표현할 수 있는 데이터 타입으로, 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 사용하여 숫자의 부호를 표현
  - 부호 비트 0은 양수, 1은 음수를 표현
  - 크게 3개의 음수 표현 방식이 존재
    - 부호-절댓값(Sign-Magnitude)
      - 정수의 부호(Sign)와 크기(Magnitude)를 별도로 저장하는 방식
      - 부호 비트 1비트를 제외한 나머지 비트에 절댓값을 2진수로 표현
      - 산술 연산 시 부호 처리가 복잡
      - $+5$ -> $0 | 0000101$
      - $-5$ -> $1 | 0000101$
    - 1의 보수(One's Complement)
      - 음수를 표현하기 위해 양수의 모든 비트를 반전시키는 방식
      - 양수는 일반적인 2진수로 표현하고, 음수는 그 2진수를 반전시킨 결과
      - 음수 연산 시 추가적인 보정 필요
      - $+5$ -> $00000101$
      - $-5$ -> $11111010$
    - 2의 보수(Two's Complement)
      - 음수를 표현하기 위해 양수의 1의 보수에 1을 더하는 방식
      - 산술 연산이 앞의 두 방식보다 효율적
      - 현대의 대부분의 컴퓨터 시스템에서 사용
      - $+5$ -> $00000101$
      - $-5$ -> $11111011$
- Unsigned
  - 양수와 0만을 표현할 수 있는 데이터 타입
  - 모든 비트를 숫자의 절댓값을 표현하는데 사용해, 동일한 비트 수에서 Signed보다 더 큰 양수를 표현할 수 있음
  - $0 \sim 2^n - 1$(n: 비트 수)까지 표현 가능


### 정수와 실수 표현 (Integer and Floating-Point Representation)	
- 정수는 기본적으로 2진수를 통해 표현하며, 음수와 소수점을 포함한 실수를 표현하기 위해 다양한 방법을 사용함
#### 고정소수점과 부동소수점
- 고정소수점(Fixed-Point)
    - 정의
      -  소수점의 위치가 고정되어 있는 실수 표현 방식
      -  부호 비트와 정수 부분을 나타내는 정수부, 소수 부분을 나타내는 소수부로 구성
    - 특징
      -  정수부와 소수부의 비트 수가 미리 정해져 있으며, 모든 수는 동일한 소수점 위치를 기준으로 표현됨
    - 장점
      -  소수점 위치가 고정되어 있어 연산이 단순하고, 복잡한 부동소수점 유닛이 필요하지 않아 부동소수점에 비해 연산이 빠름
      -  정수부와 소수부의 비트 수가 고정되어 있기 때문에, 메모리 사용이 예측 가능하고 최적화 될 수 있음
    - 단점
      -  소수점 위치가 고정되어있어 표현할 수 있는 수의 범위가 제한적
      -  부동소수점에 비해 소수부 정밀도가 낮음
    - 예시
      -  소수부 구하는 법 - 10진수를 2진수로 변환하는법의 반대로 2를 곱해가며 나머지를 구해 결합
         -  $0.625$를 2진수로 변환
         1. $0.625 * 2 = 1.25$ -> 나머지 $1$을 제외하고 다음 계산
         2. $0.25 * 2 = 0.5$ -> 나머지 $0$을 제외하고 다음 계산
         3. $0.5 * 2 = 1$ -> 나머지 $1$을 제외
         4. 0.625의 고정소수점 변환 소수부는 $101$
      -  $14.625$의 16비트에서 고정소수점으로 변환 - 1비트는 부호 비트로 사용하고, 정수부 7비트, 소수부 8비트
         1. $14$ -> $1110$
         2. $0.625$ -> $101$
         3. 양수이므로 부호 비트는 0, 정수부는 오른쪽부터, 소수부는 왼쪽부터 채워 $0 | 0001110 | 10100000$ 로 표현
- 부동소수점
    - 정의 
      -  수의 소수점 위치가 고정되어 있지 않고, 수의 크기에 따라 유동적으로 변할 수 있도록 설계된 수 체계
      -  부호 비트와 지수를 나타내는 지수부, 소수점 아래를 나타내는 가수부로 구성
    - 특징
      -  부동소수점 수는 항상 정규화(Normalization)된 형태로 표현 - 가수가 1.F형태를 가지도록 조정되어 표현
      -  지수부를 통해 소수점의 위치를 조정할 수 있음
      -  IEEE 754 표준을 통해 32비트(단정도, Single Precision), 64비트(배정도, Double Precision)를 사용하여 실수를 표현
      -  지수부에 bias를 더하여 지수부가 10진수 기준으로 0~127구간은 음수, 128~255구간은 양수를 나타내어 음의 지수를 표현
    - 장점
      -  소수점 위치를 조정함으로써, 매우 큰 수부터 매우 작은 수까지 표현 가능
      -  높은 정밀도를 가져 복잡한 수학적 연산이나 데이터 분석에서 고정소수점에 비해 정확한 결과를 얻을 수 있음
      -  IEEE 754표준을 통해 부동소수점 연산의 일관성을 보장하여, 다양한 컴퓨터 시스템과 프로그래밍 언어 간 호환성이 높음
    - 단점
      -  고정소수점 연산에 비해 복잡하고 많은 자원을 소모할 수 있음
      -  유한한 비트 수로 실수를 표현하기 때문에, 모든 실수를 정확하게 표현할 수 없음
    - 예시
      -  $6.5$를 단정도 부동소수점으로 변환 - 1비트는 부호 비트로 사용하고, 지수부 8비트, 가수부 23비트
         1. $6$ -> $110$
         2. $0.5$ -> $1$
         3. $6.5$ -> $110.1$
         4. 정규화하여 $1.101 * 2^2$
         5. 양수이므로 부호 비트는 0, 지수가 양수이므로 bias를 더하고 오른쪽부터, 가수부는 소수점 아래를 왼쪽부터 채워 $0 | 10000001 | 10100000000000000000000$으로 표현(정수 1은 모든 부동소수점 표현에서 같이 존재하므로 무시)
#### IEEE 754 표준 (IEEE 754 Standard) - 표현, 정밀도, 반올림
- 컴퓨터에서 부동소수점 수를 표현하고 연산하는 방식을 규정한 국제 표준
- 표현
  - 부동소수점을 단정도와 배정도 두 가지 형식으로 정의
     - 단정도(Single Precision, 32bit)
       -  부호 비트 1비트, 지수 비트 8비트, 가수 비트 23비트
     - 배정도(Double Precision, 64bit)
       - 부호 비트 1비트, 지수 비트 11비트, 가수 비트 52비트
  - 특수 값을 따로 정의 하여 특수한 상황을 처리
    - Zero
      - 양의 제로 - 부호 비트 0, 지수 비트 모두 0, 가수 비트 모두 0
      - 음의 제로 - 부호 비트 1, 지수 비트 모두 0, 가수 비트 모두 0
    - Infinity
      - 양의 무한대 - 부호 비트 0, 지수 비트 모두 1, 가수 비트 모두 0
      - 음의 무한대 - 부호 비트 1, 지수 비트 모두 1, 가수 비트 모두 0
    - NaN(Not a Number)
      - 지수 비트 모두 1, 가수 비트 모두 0
- 정밀도(Precision)
  - 부동소수점 수가 얼마나 정확하게 실수를 표현할 수 있는가를 나타내며, IEEE 754 표준에서는 단정도와 배정도로 정밀도를 구분
    - 단정도
      - 가수 비트 23비트로 약 7자리 십진수를 표현 가능
    - 배정도
      - 가수 비트 52비트로 약 16자리 십진수를 표현 가능
- 반올림(Rounding)
  - 부동소수점 연산에서 결과가 표현 가능한 정밀도를 초과할 때 반올림 필요
  - 연산 결과가 가수부의 비트를 초과할 때 반올림 모드를 이용해 연산 결과를 표현
  - 반올림 모드(Rounding mode)
    - 짝수로 반올림(round to nearest, ties to even)
      - 반올림하려는 수의 소수부분이 정확히 0.5일 경우, 소수부분의 앞 자리 정수가 짝수인 경우 가장 가까운 작은 정수로 반올림, 앞자리 숫자가 홀수라면 가장 가까운 큰 정수로 반올림
      - $4.5$의 반올림은 $4$, $5.5$의 반올림은 $6$
    - 큰 절댓값으로 반올림(round to nearest, ties away from zero)
      - 반올림하려는 수의 소수부분이 정확히 0.5일 경우, 소수부분의 앞 자리 정수에 관계없이 가장 가까운 정수 쪽으로 반올림
      - $4.5$의 반올림은 $5$, $5.5$의 반올림은 $6$
    - 올림(round toward +∞)
      - 반올림하려는 수가 양의 무한대에 가까워지는 경우, 해당 양의 무한대 값을 반올림 결과로 사용(가장 가까운 큰 정수)
      - $3.2$의 반올림은 $4$, $5.7$의 반올림은 $6$
    - 버림(round toward -∞)
      - 반올림하려는 수가 음의 무한대에 가까워지는 경우, 해당 음의 무한대 값을 반올림 결과로 사용(가장 가까운 작은 정수)
      - $3.7$의 반올림은 $3$, $-2.8$의 반올림은 $-3$
    - 절삭(round toward zero)
      - 반올림하려는 수의 소수 부분을 무시하고, 가장 가까운 정수로 반올림
      - $2.9$의 반올림은 $2$, $-2.9$의 반올림은 $-2$
  - IEEE 754에서는 round to nearest, ties to even을 기본값으로 사용
  - 반올림 오류(Rounding Errors)
    - 부동소수점 수를 고정된 비트수로 표현하는 과정에서 발생하는 오차로, 실제 수를 반올림을 통해 근사치로 표현하여 소수점 이하의 비트가 잘려나가면서 발생
    - 반복적인 연산이나 누적 계산에서 오차가 누적되어 정확도가 저하
    - 높은 정밀도를 사용하거나, 정수로 변환하여 계산 후 실수로 다시 변환하여 오차를 최소화
    - 예시
      - $0.1$을 2진수로 변환하면 $0.0001100110011001100110011...$의 무한소수로 변환되는데, 이 과정에서 실제 값과 오차가 발생
      - $0.1 + 0.2 = 0.3$이 되어야 맞으나 컴퓨터 2진수 환경에서 계산시 단정도 기준 $0.30000000447034836$으로 오차 발생
      - 게산 전 각 수에 10을 곱하여 $1 + 2$로 변환하여 계산 후, 다시 10으로 나누어 실수로 변환하여 오차 발생 방지
### 데이터 연산 (Data Operations)	
- 컴퓨터가 데이터를 처리하기 위해 수행하는 모든 계산 및 논리적 작업
- 산술 연산, 논리 연산, 시프트 연산 등
#### 산술 연산 (Arithmetic Operations)
- 숫자 데이터를 처리하는 기본적인 연산
- 종류
  - 덧셈(+)
    - 두 숫자를 더하는 연산
    - $3 + 5 = 8$
  - 뺄셈(-)
    - 한 숫자에서 다른 숫자를 빼는 연산
    - $5 - 3 = 2$
  - 곱셈(*)
    - 두 숫자를 곱하는 연산
    - $3 * 5 = 15$
  - 나눗셈(/)
    - 한 숫자를 다른 숫자로 나누는 연산
    - $15 / 3 = 5$
  - 모듈로 연산(%)
    - 한 숫자를 다른 숫자로 나누고 나머지를 구하는 연산
    - $20 \% 3 = 2$
#### 논리 연산 (Logical Operations)
- Boolean 데이터를 처리하는 연산, 조건 판단에 주로 사용
- 비트에 적용하여 비트 연산(Bitwise Operations)으로 사용
- 비트에서 참(True)는 1, 거짓(False)는 0으로 표현
- 종류
  - 논리곱(AND)
    - 두 논리값이 모두 참일 때만 참을 반환
    - True AND False = False
    - True AND True = True
  - 논리합(OR)
    - 두 논리값 중 하나라도 참일 때 참을 반환
    - True OR False = True
  - 부정(NOT)
    - 논리값을 반대로 반환
    - NOT True = False
  - 배타적 논리합(XOR, Exclusive OR)
    - 두 값이 서로 다를 때 참을 반환
    - True XOR True = False
    - True XOR False = True
  - 부정 논리곱(NAND)
    - 논리곱 연산의 결과를 반대로 반환
    - True NAND False = True
    - True NAND True = False
  - 부정 논리합(NOR)
    - 논리합 연산의 결과를 반대로 반환
    - True NOR False = False
#### 시프트 연산 (Shift Operations)
- 2진수로 표현된 데이터를 특정 방향으로 일정한 비트 수만큼 이동시키는 연산
- 2의 제곱수로 곱하거나 나누는 연산을 빠르게 수행할 수 있고, 특정 비트를 추출하거나 설정할 때 사용
- 크게 논리 시프트, 산술 시프트, 순환 시프트로 나뉨
- 논리 시프트(Logical Shift)
  - 비트를 단순히 왼쪽이나 오른쪽으로 이동시키고, 이동한 자리에 0을 채우는 연산
  - 부호 비트를 유지하지 않아 주로 Unsigned 데이터에서 사용
  - 논리 시프트 왼쪽(Logical Shift Left, LSL) - Unsinged
    - 데이터를 왼쪽으로 이동시키고, 오른쪽 끝에 0을 채움
    - $69 << 1 = 138$ -> ($01000101$ -> $10001010$)
  - 논리 시프트 오른쪽(Logical Shift Right, LSR) - Unsinged
    - 데이터를 오른쪽으로 이동시키고, 오른쪽 끝에 0을 채움
    - $22 >> 1 = 11$ -> ($00010110$ -> $00001011$)
- 산술 시프트(Arithmetic Shift)
  - 부호 비트를 유지하면서 비트를 이동시키는 연산
  - 주로 Signed 데이터에서 사용하며, 2의 거듭제곱수를 곱하거나 나누는데 사용
  - 산술 시프트 왼쪽(Arithmetic Shift Left, ASL) - 부호 절댓값 표현
    - $-33 << 1 = -66$ -> ($10100001$ -> $11000010$)
  - 산술 시프트 오른쪽(Arithmetic Shift Right, ASR) - 부호 절댓값 표현
    - $-33 >> 1 = -16$ -> ($10100001$ -> $10010000$)
- 순환 시프트(Circular Shift)
  - 이동되어 제거된 비트가 다시 반대쪽 끝으로 순환되어 돌아오는 연산
  - 순환 시프트 왼쪽(Circular Shift Left, CSL) - Unsinged
    - $149 << 1 = 43$ -> ($10010101$ -> $00101011$)
  - 순환 시프트 오른쪽(Circular Shift Right, CSR) - Unsinged
    - $139 >> 1 = 197$ -> ($10001011$ -> $11000101$)

--- 	
## 중앙처리장치 (CPU, Central Processing Unit)		
- 컴퓨터 시스템의 핵심 구성 요소
- 데이터의 처리와 명령어의 실행을 담당
### CPU의 구조와 구성 요소 (CPU Architecture and Components)
- 크게 제어 유닛, 산술 논리 장치, 레지스터로 구성   
![CPU 구조](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/ABasicComputer.gif/300px-ABasicComputer.gif)   
Image source : https://commons.wikimedia.org/wiki/File:ABasicComputer.gif
#### 산술 논리 장치(ALU, Arithmetic Logic Unit)
- 실제로 연산을 수행하는 부품으로 산술 및 논리 연산을 처리
- 레지스터를 통해 입력받은 피연산자와 제어 유닛으로부터 받은 명령에 따라 ALU가 연산을 수행, 결과는 다시 레지스터에 저장되어 필요에 따라 메모리에 전송
- ALU의 연산 결과를 플래그 레지스터에 저장함으로써, 추가적인 상태 정보(플래그)를 제공할 수 있음   
![ALU 도식화](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdo2P17%2Fbtsi60toHGo%2Fhb4andwQLYxUXTVIZ3JKkk%2Fimg.png)    
Image source : https://maloveforme.tistory.com/152
#### 레지스터 (Registers)
- CPU 내부에 위치한 고속 메모리
- 연산에 필요한 데이터를 임시로 저장하는 역할
- 범용 레지스터(General purpose register)
  - 데이터의 임시 저장 공간으로, 연산 처리 및 데이터의 주소를 지정하고, 컴퓨터의 장치들을 제어하는 역할
    |종류|용도|
    |---|---|
    |EAX|산술, 논리 연산을 수행하고, 함수의 return 값 저장|
    |ECX|반복문에서 카운터로 사용|
    |EDX|EAX와 함께 사용되어 연산을 보조|
    |EBX|메모리 주소를 저장|
    |EDI|데이터를 옮길 때 사용되는 목적지의 주소를 저장|
    |ESP|사용중인 스택의 위치를 가리킴|
    |EBP|스택의 제일 아랫부분의 주소를 저장|
    |ESI|데이터를 옮길 때 원본의 주소를 저장|
- 특수 목적 레지스터(Special purpose register)
    |종류|용도|
    |---|---|
    |프로그램 카운터(PC, Program Counter)|다음에 실행될 명령어의 주소를 저장|
    |누산기(AC, Accumulator)|산술 논리 장치의 연산 결과를 임시로 저장|
    |명령어 레지스터(IR, Instruction Register)|명령어를 호출해서 해독하기 위해 현재 명령어를 임시로 저장|
    |메모리 주소 레지스터(MAR, Memory Address Register)|읽기와 쓰기 연산을 수행할 주기억장치 주소를 저장|
    |메모리 버퍼 레지스터(MBR, Memory Buffer Register)|주기억장치의 내용을 임시로 저장하는 역할|
    |인덱스 레지스터(IX, Index Register)|인덱스 주소 지정 방식에서 인덱스를 저장|
    |프로그램 상태 레지스터(PSR, Program Status Register)|CPU의 현재 상태 정보를 저장|
    |스택 포인터(SP, Stack Pointer)|스택의 최상위 주소를 저장|
#### 제어 유닛(Control Unit)
- 하드웨어 구성 요소들을 조율하고 관리하는 역할
- 명령어 해석, ALU와 메모리 간 데이터 흐름을 제어 신호를 통해 제어
- 클럭 신호를 통해 컴퓨터의 각 부품이 동기화되어 동작하도록 제어
- CPU 외부에 위치한 여러 하드웨어 구성 요소들에게 제어 신호를 보내, 메모리와 입출력 장치와의 데이터 교환을 제어   
    ![제어 유닛 도식화](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDIRLv%2Fbtsi41Gnu2D%2F1OiQ4jwiVV7k4kksHfb4TK%2Fimg.png)   
    Image source : https://maloveforme.tistory.com/152
### 명령어 사이클 (Instruction Cycle)
- 한 개의 명령어를 인출하고 실행하는데 필요한 전체 과정
- 명령어 인출 단계와 실행 단계로 이루어지며, 각각 인출 사이클, 실행 사이클이라고 부름
- 인출 사이클(Fetch cycle)
  - 명령어 사이클의 시작 단계에서 프로그램 카운터가 가리키는 기억장치의 위치로부터 명령어를 인출해오는 과정
  - 인출 사이클에서 각 단계별로 수행되는 마이크로-연산(micro-operation), 각 $t$는 CPU 클록의 각 주기를 가리킴
    1. $t_0$ : MAR <- PC
    2. $t_1$ : MBR <- M[MAR], PC <- PC + 1
    3. $t_2$ : IR <- MBR
- 실행 사이클(Excute cycle)
  - 인출된 명령어 코드를 해독하고, 필요한 연산을 수행
  - 실행 사이클에서 수행되는 마이크로-연산은 명령어의 연산코드(operation code)에 따라 결정
  - 데이터의 이동(LOAD addr)
    1. $t_0$: MAR <- IR(addr)
    2. $t_1$ : MBR <- M[MAR]
    3. $t_2$ : AC <- MBR
  - 데이터의 저장(STA addr)
    1. $t_0$ : MAR <- IR(addr)
    2. $t_1$ : MBR <- AC
    3. $t_2$ : M[MAR] <- MBR
  - 데이터 처리(ADD addr)
    1. $t_0$ : MAR <- IR(addr)
    2. $t_1$ : MBR <- M[MAR]
    3. $t_2$ : AC <- AC + MBR
  - 프로그램 제어(JUMP addr)
    1. $t_0$ : PC <- IR(addr)
- 인터럽트 사이클(Interrupt cycle)
  - 인터럽트(Interrupt)
    - 순차적인 명령어 실행을 중단하고, 다른 프로그램을 처리하도록 하는 신호
    - 예외(exception) - 동기 인터럽트(Synchronous interrupts)
      - CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때 발생하는 인터럽트
    - 인터럽트(interrupt) - 비동기 인터럽트(Asynchronous interrupts)
      -  입출력 장치에서의 알림처럼 CPU 외부에서 처리할 예외 상황이 발생할때 발생하는 인터럽트
      -  막을 수 있는 인터럽트(Maskable interrupt)와 막을 수 없는 인터럽트(Non-maskable interrupt)로 나뉨
  - 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)
    - 원래의 명령어 실행을 중단하고, 요구된 인터럽트를 처리해주기 위해 수행하는 프로그램 루틴
  - 인터럽트 요구 신호를 검사하고, 현재의 PC 내용을 스택에 저장한 다음, PC에 해당 ISR의 시작 주소를 적재하는 과정이 인터럽트 사이클
  - 인터럽트 사이클의 마이크로-연산
    1. $t_0$ : MBR <- PC
    2. $t_1$ : MAR <- SP PC <- ISR의 시작 주소
    3. $t_2$ : M[MAR] <- MBR, SP <- SP - 1
- 간접 사이클(Indirect Cycle)
  - 명령어의 오퍼랜드가 간접 주소 방식인 경우 유효주소를 계산하기 위해 메모리에 접근하는 사이클
  - 간접 사이클의 마이크로-연산
    1. $t_3$: MAR <- IR(addr)
    2. $t_4$ : MBR <- M[MAR]
    3. $t_5$ : IR(addr) <-MBR
- 전체 사이클   
    ![전체 사이클](https://velog.velcdn.com/images/hyunji015/post/3bff0bcd-37a1-48a7-8869-9f40db58944e/image.png)   
    Image source : https://velog.io/@hyunji015/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%82%AC%EC%9D%B4%ED%81%B4%EA%B3%BC-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8
### 메모리 접근 방식 (Memory Access Methods)
- CPU가 명령어 수행 시 오퍼랜드의 위치를 해석하는 방식
- 즉시 주소 지정 방식(Immediate Addressing mode)
  - 명령어 자체에 오퍼랜드를 포함시키는 방식
  - 데이터를 메모리나 레지스터로부터 찾는 과정이 없기에 빠르나 고정된 값만 사용 가능
- 직접 주소 지정 방식(Direct Addressing mode)
  - 명령어에 오퍼랜드의 메모리 주소를 직접적으로 명시하는 방식
  - 단순하고 직관적이나 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들음
- 간접 주소 지정 방식(Indrice Addressing mode)
  - 명령어에 오퍼랜드의 실제 주소를 저장하고 있는 레지스터나 메모리 주소를 지정하는 방식
  - 명령어에 포함된 주소는 포인터로, 두 번의 메모리 접근이 필요해 느림
- 레지스터 주소 방식(Register Addressing mode)
  - 직접 주소 지정 방식과 비슷하게 오퍼랜드를 저장한 레지스터를 명령어에 직접 명시하는 방식
  - 레지스터에서 데이터를 찾기 때문에 빠름
- 레지스터 간접 주소 지정 방식(Register Indirect Addressing mode)
  - 오퍼랜드를 메모리에 저장하고, 유효 주소를 저장한 레지스터를 명령어에 명시하는 방식
  - 간접 주소 지정 방식과 비슷하지만, 한 번의 메모리 접근만 필요해 비교적 빠름

--- 		
## 메모리 구조 (Memory Architecture)
- CPU가 메모리에 더 빨리 접근하기 필요에 따라 메모리의 종류가 나뉨
### 메모리 계층 구조 (Memory Hierarchy)	
- 필요에 따라 여러 종류의 메모리를 나눠 CPU가 순차적으로 액세스 함으로써 최적의 효율을 낼 수 있게 하는 구조
- 지역성의 원리(Principle of Locality)
  - 메모리는 지역성의 원리를 이용하여 계층적으로 구성
  - 시간적 지역성(Temporal locality)
    - 어떤 데이터가 참조되면 곧바로 다시 참조될 가능성이 높다는 원칙
  - 공간적 지역성(Spatial locality)
    - 어떤 데이터가 참조되면 곧바로 그 주위의 데이터가 참조될 가능성이 높다는 원칙
- 계층의 순서는 레지스터(CPU), 캐시기억장치(CPU), 주기억장치(메모리), 보조기억장치(하드디스크) 순으로, 위로 올라갈수록 접근시간은 감소하고, 속도는 증가하며, 비용이 비싸지고, 용량은 적어짐   
![계층구조](https://velog.velcdn.com/images/ajm0718/post/a7d2d7e5-b835-4fb1-8bdd-9bad0afcc45e/image.png)   
Image source : https://velog.io/@ajm0718/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0
- CPU는 필요한 데이터를 참조할 때, 상위 계층부터 접근하여 데이터를 찾을 수 없다면 하위 계층으로 차례대로 접근
- 인접한 계층의 메모리 사이에서만 데이터 복사가 가능하며, 두 계층 간 정보의 최소 단위를 블록(block) 또는 라인(line)이라고 부름
- 내부 기억장치(Internal memory)
  - CPU가 주소를 발생하고, 그 주소에 의해 데이터를 읽거나 쓰는 동작을 수행할 수 있는 메모리
  - 레지스터, 캐시 메모리, 주기억장치가 해당됨
- 외부 기억장치(External memory)
  - CPU가 직접 액세스하지 못하고, 장치 제어기를 통해 액세스 할 수 있는 메모리
  - HDD, SDD 등의 보조기억장치가 해당됨
### 캐시 메모리 (Cache Memory)	
- 메모리 계층 구조에서 중간에 위치한 고속의 임시 저장 공간
- CPU와 주기억장치의 사이에 위치하여 속도 차이에 의한 병목 현상을 줄이기 위한 역할
- 지역성 원리를 기반으로 동작
- 주로 L1, L2, L3캐시로 구성되어 있으며, 이 캐시들 간에도 계층 구조를 가지고 동작
#### 직접 매핑(Direct Mapping)
- 주기억장치의 블록들이 지정된 어느 한 캐시 라인에만 적재될 수 있는 매핑 방식
- 주기억장치의 주소가 태그 필드($t$), 라인 필드($l$)와 단어 필드($w$)로 구성된 것으로 해석됨
- 주기억장치의 블록 $j$가 적재될 수 있는 캐시 라인의 번호 $i$는 모듈로 함수에 의해 결정
- $i = j \, mod \, m$
- 예로 캐시 라인의 수 $m=4$라면, 주기억 장치의 여섯 번째 블록 $j=6$은 $6 \, mod \, 4 = 2$이므로 캐시의 2번 라인에 적재
- 구조가 단순하지만 공간적 지역성에 의해 특정 캐시 라인을 계속해서 교체해야 한다면, 적중률과 성능이 낮아짐
#### 완전 연관(Fully Associative)
- 주기억장치의 블록이 캐시의 어느 라인으로든 적재될 수 있는 매핑 방식
- 주기억장치의 주소가 태그 필드($t$)와 단어 필드($w$)로 구성된 것으로 해석됨
- 주기억장치로부터 인출된 데이터 블록을 캐시의 빈 라인에 라인 번호에 따라 차례대로 적재
- 비어 있는 라인 없이 캐시가 완전히 채워진 상태에서 새로운 블록이 인출되어 온다면, 교체 알고리즘을 통해 기존의 블록을 지우고(변경된 적이 있다면 주기억장치에 갱신), 새로운 블록을 적재
#### 집합 연관(Set-Associative)
- 캐시는 $v$개의 집합으로 나뉘며, 각 세트는 $k$개의 라인들로 구성
- 주기억장치의 주소가 태그 필드($t$), 세트 필드($s$)와 단어 필드($w$)로 구성된 것으로 해석됨
- $m$을 캐시 라인의 전채 개수, $i$를 세트 번호, $j$를 주기억장치의 블록 번호로 가정할 때,   
$m = v * k$   
$i = j \, mod \, v$   
의 수식을 통해 $m$과 $i$가 결정됨
- 세트당 라인의 개수에 따라 k-way 집합-연관 매핑이라고 부름
- 비어 있는 라인 없이 캐시가 완전히 채워진 상태에서 특정 세트를 공유하는 새로운 블록이 인출되어 온다면, 교체 알고리즘을 통해 기존의 블록을 지우고(변경된 적이 있다면 주기억장치에 갱신), 새로운 블록을 적재
#### 캐시 적중률(Cache Hit Rate)
- CPU에서 메모리에 접근하기 전, 먼저 캐시 메모리에 현재 원하는 데이터가 있는지 여부를 확인, 이때 필요한 데이터가 있는 경우를 적중(Hit), 없는 경우를 실패(Miss)라고 하며, 요청한 데이터를 캐시 메모리에서 찾을 확률을 적중률(Hit ratio)이라고 부름
- 적중한다면 단어들 중의 하나를 인출하여 CPU로 보내고, 실패한다면 주소를 주기억장치로 보내 해당 단어가 포함된 블록을 인출
- 완전 연관에서의 캐시 적중
  - 데이터가 필요할 때, 주기억장치 주소의 태그 필드와 캐시의 모든 라인들의 태그를 비교하여 적중 여부를 확인
  - 주기억장치 주소의 태그 필드와 캐시의 모든 라인들의 태그를 비교해야 하므로, 시간이 오래 걸림
- 집합 연관에서의 캐시 적중
  - 주기억장치 주소의 태그 필드와 지정된 세트에 포함된 라인들의 태그를 비교하여 적중 여부를 확인
  - 특정 세트에서만 태그를 비교하면 돼, 완전 연관에서보다 속도가 빠름
#### 캐시 교체 알고리즘(Cache Replacement Algorithm)
- 캐시 실패 상황시, 어떤 블록을 버리고 새로운 블록을 적재할 지 정하는 알고리즘
##### FIFO
- 가장 먼저 들어온 블록을 새로운 블록으로 교체하는 방식
##### LRU
- 캐시에 남아있는 블록들 중 가장 오랫동안 사용되지 않은 블록을 새로운 블록으로 교체하는 방식
- 시간적 지역성에 의해 높은 적중률을 보여 효율적
##### LFU
- 참조 횟수가 가장 적은 블록을 새로운 블록으로 교체하는 방식
### 가상 메모리 (Virtual Memory)	
- 애플리케이션이 실행될 때, 실행에 필요한 일부분만 주기억장치에 올라가며 애플리케이션의 나머지는 보조기억장치에 남게 되어 보조기억장치가 주기억장치처럼 작동하는 구조
#### 페이징(Paging)
- 프로세스를 일정한 물리적 크기로 자르고, 이를 메모리에 불연속적으로 할당해서 관리하는 구조
- 메모리에 공간이 있음에도 불구하고, 연속된 공간의 크기가 프로세스의 크기보다 작아 할당하지 못하는 외부 단편화의(External Fragmentation) 해결 방법으로 불연속 할당을 채택한 구조
- 페이지(Page)
  - 가상 메모리를 일정한 크기로 나눈 블록
- 프레임(Frame)
  - 물리 메모리를 일정한 크기로 나눈 블록
- 페이지의 크기는 프레임의 크기와 동일하게 설정
- 모든 프로세스를 페이지로 조각화하고, 페이지를 프레임에 불연속적으로 할당
- 페이지 번호와 오프셋을 통해 페이지의 가상 주소를 표현
- 페이지 테이블(Page table)을 통해 어떤 페이지가 프레임에 매핑되는지 저장
![페이징 예시](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbO4ldE%2Fbtr7n1xSfrQ%2Fko60Dw8B1SCV57J6ghP5a0%2Fimg.png)   
Image source : https://hojunking.tistory.com/110
- 물리 메모리가 프레임 크기로 나누어 떨어지지 않는 경우 실제로 사용되지 않는 메모리 영역이 발생하는 내부 단편화(nternal Fragmentation)가 발생할 수 있음
- 필요한 페이지가 물리 메모리에 없을 때 발생하는 Page Fault 인터럽트가 발생했을 때, 비어있는 프레임이 있다면 페이지를 페치하고, 없다면 페이지 교체 알고리즘을 통해 교체 
#### 세그멘테이션(Segmentation)
- 프로세스를 논리적 내용을 기반으로 나눠 메모리에 할당해서 관리하는 구조
- 프로세스를 main program, function, method, object 등 세그먼트의 집합으로 표현
- 세그먼트의 크기는 일정하지 않음
- 세그먼트 번호와 오프셋을 통해 세그먼트의 논리주소를 표현
- 세그먼트 테이블(Segment table)을 통해 세그먼트의 물리 주소와 크기를 저장
![세그멘테이션 예시](https://code-lab1.com/wp-content/uploads/2024/12/img-1-6-768x410.png)   
Image source : https://code-lab1.com/%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98/
- 세그먼트의 크기는 일정하지 않아 다양한 크기의 빈 메모리 공간이 발생해 외부 단편화 문제가 발생할 수 있음
#### 페이지 교체 알고리즘
- 필요한 페이지가 주기억장치에 적재되지 않았을 시, 어떤 페이지 프레임을 선택하여 교체(스왑 아웃, Swap out)할 것인지 결정하는 방법
##### LRU
- 가장 오랫동안 사용되지 않은 페이지를 스왑 아웃
- 시간적 지역성에 의해 높은 성능을 보임
- 프로세스가 주기억장치에 접근할때마다 참조된 페이지 시간을 기록해야 하므로 오버헤드가 발생
##### FIFO
- 메모리에 가장 먼저 페치된 페이지를 스왑 아웃
- 지역성을 고려하지 않아 성능이 떨어짐
##### 최적 교체(Optimal Replacement)
- 앞으로 사용할 페이지를 파악해 앞으로 사용하지 않을 가능성이 제일 높은 페이지를 스왑 아웃
- 실제로 미래의 접근 패턴을 알고 구현할 수 없음
### TLB (Translation Lookaside Buffer)	
- 가상 주소와 물리 주소 간의 매핑 정보를 저장하는 캐시 메모리
- 최근에 사용된 페이지 매핑 정보를 저장하여 페이지 테이블을 참조하지 않고 물리 주소를 얻을 수 있도록 함
- 가상 주소가 TLB에 존재하면 적중으로 바로 물리 주소를 통해 메모리에 접근하고, 실패하면 페이지 테이블을 참조하여 물리 주소를 획득한 후, TLB에 저장
--- 		
## 입출력 시스템 (I/O Systems)
- 컴퓨터가 외부 장치와 데이터를 주고받을 수 있도록 하는 하드웨어 및 소프트웨어의 집합
- 사용자, 외부 저장장치, 네트워크 등과의 상호작용을 관리
### 입출력 장치와 동작 원리 (I/O Devices and Operations)
- 입력 장치
  - 사용자로부터 데이터를 입력받는 장치
  - 키보드, 마우스, 스캐너 등
- 출력 장치
  - 처리된 데이터를 사용자에게 출력하는 장치
  - 모니터, 프린터, 스피커 등
- 저장 장치
  - 데이터를 영구적으로 저장하는 장치
  - HDD, SDD, USB 등
- 네트워크 장치
  - 데이터 통신을 위한 장치
  - 네트워크 카드, 라우터 등
- 입출력 컨트롤러(I/O Controller)
  - 입출력 장치와 컴퓨터의 주요 구성 요소 간 통신을 관리하는 하드웨어
- 동작 원리
  1. 명령어 실행 - CPU가 입출력 명령어를 실행하여 데이터를 입력 또는 출력
  2. 장치 제어 - 입출력 컨트롤러가 장치와 통신하여 데이터를 전송하거나 수신
  3. 데이터 전송 - 버스를 통해 데이터를 CPU와 입출력 장치 간에 전송
  4. 상태 관리 - 제어 신호와 상태 정보를 통해 데이터 전송 성공 여부를 확인, 필요한 경우 오류 처리	
### 입출력 제어 방식 (I/O Control Mechanisms)	
- CPU가 입출력 장치와 데이터를 주고받는 방식을 제어하는 메커니즘 
- 폴링(Polling)
  - CPU가 주기적으로 입출력 장치의 상태를 확인하여 데이터가 준비되었는지 검사하는 방식
  - 입출력 장치의 개수가 증가할수록 CPU의 이용률이 낮아져 성능이 저하
- 인터럽트(Interrupt)
  - I/O를 요청한 프로세스를 블록시키고 CPU를 다른 프로세스에게 양도한 후 입출력 이벤트가 발생했을 때 CPU에 이를 알려 처리하는 방식
  - CPU가 필요할 때만 입출력 장치와 통신하고, 그 이외에는 다른 프로세스를 실행하여 폴링 방식에 비해 성능이 높음
#### 프로그램 제어(Programmed I/O)
- CPU가 직접 입출력 장치와 데이터를 주고받는 방식
- CPU가 입출력 장치를 폴링하여 데이터 전송이 가능한지 확인하고, 가능한 경우 데이터를 직접 전송
- 동작 원리
  1. 명령어 실행 - CPU가 입출력 명령어를 실행하여 데이터 전송을 요청
  2. 상태 확인 - 입출력 장치의 상태 레지스터를 읽어 데이터 전송이 가능한지 확인
  3. 데이터 전송이 가능하다면, CPU가 데이터를 입출력 장치로 직접 전송
- 장점
  - CPU가 모든 데이터 전송 과정을 직접 제어하므로 예측 가능성이 높음
- 단점
  - 입출력 장치의 상태를 지속적으로 확인해야 하므로 CPU의 자원을 많이 소모
  - 데이터 전송 동안 CPU가 다른 작업을 수행할 수 없어 전체 시스템 효율성이 떨어짐
  - 입출력 장치가 준비될 때까지 CPU가 대기해야 하므로 응답 시간이 길어질 수 있음
#### 인터럽트 방식(Interrupt-driven I/O)
- 입출력 장치가 데이터 전송 준비가 됐을 때 CPU에 인터럽트 신호를 보내 CPU가 작업을 수행하도록 하는 방식
- CPU가 지속적으로 폴링하지 않고, 필요한 경우에만 처리
- 동작 원리
  1. 명령어 실행 - CPU가 입출력 명령어를 실행하여 데이터 전송을 요청
  2. 인터럽트 대기 - 입출력 장치가 데이터 전송이 완료되거나 준비되었을 때 CPU에 인터럽트를 전송
  3. 인터럽트 처리 - CPU가 현재 작업을 일시 중단하고, 인터럽트 핸들러를 실행하여 데이터 전송을 처리
  4. 작업 재개 - 인터럽트 핸들러 실행 후, CPU가 이전 작업을 재개
- 장점
  - CPU가 다른 작업을 수행할 수 있어 전체 시스템 효율성이 높음
  - 지속적인 폴링이 필요 없어 CPU 부하가 줄어듬
  - 입출력 장치가 준비되는 즉시 CPU가 처리할 수 있어 응답 시간이 단축됨
- 단점
  - 잦은 인터럽트 발생 시 오버헤드가 발생할 수 있음
#### DMA(Direct Memory Access)
- CPU를 거치지 않고 입출력 장치가 메모리와 직접 데이터 전송을 수행하는 방식
- 입출력 제어기의 DMA 제어기가 데이터 전송을 관리
- 동작 원리
  1. 전송 요청 - CPU가 DMA 컨트롤러에 데이터 전송을 요청, 이때 소스 주소, 목적지 주소, 데이터 크기 등을 지정
  2. 전송 시작 - DMA 컨트롤러가 데이터 전송을 시작하고, 메모리와 입출력 장치 간에 데이터를 직접 전송
  3. 전송 완료 - 데이터 전송이 완료되면 DMA 컨트롤러가 CPU에 인터럽트를 보내어 전송 완료를 알림
  4. CPU 개입 - CPU가 인터럽트를 받아 전송 완료 후의 작업을 수행
- 장점
  - 데이터 전송에 CPU가 직접 개입하지 않아 CPU 자원을 절약
  - DMA가 하드웨어 수준에서 직접 전송을 수행해, 전송 속도가 빠름
  - 데이터 전송과 CPU의 다른 작업을 동시에 수행할 수 있어 시스템 전체의 처리 능력이 향상
- 단점
  - DMA 컨트롤러가 추가로 필요하며, 하드웨어 설계가 복잡해짐
  - 메모리 버스나 다른 하드웨어 자원의 충돌이 발생할 수 있음
### I/O 버스와 데이터 전송 (I/O Bus and Data Transfer)	
#### I/O 버스(I/O Bus)
- CPU, 메모리, 입출력 장치 간의 데이터를 전송하는 통로
- 구성 요소
  - 데이터 버스(Data Bus)
    - 데이터의 전송을 담당
    - CPU와 입출력 장치 간 데이터를 주고받는 통로
    - 데이터 버스의 폭(비트 수)이 클수록 한 번에 전송할 수 있는 데이터의 양이 증가
  - 주소 버스(Address Bus)
    - 데이터가 전송될 메모리나 입출력 장치의 주소를 지정
    - 주소 버스의 폭은 시스템이 접근할 수 있는 최대 주소 공간을 결정
  - 제어 버스(Control Bus)
    - 데이터 전송의 방향, 읽기/쓰기 신호, 인터럽트 신호 등 제어 신호를 전달
- I/O 버스의 유형
  - 병럴 버스(Parallel Bus)
    - 여러 개의 데이터 버스에서 동시에 데이터를 전송하는 방식
    - 여러 비트를 동시에 전송하여 높은 데이터 전송률을 구현
    - 신호 간섭 및 지연으로 인해 전송 거리가 짧음
  - 직렬 버스(Serial Bus)
    - 데이터 비트를 하나씩 순차적으로 전송하는 방식
    - 신호 간섭이 적어 긴 거리에서도 안정적인 전송이 가능
#### 데이터 전송(Data Transfer)
- 동기 전송(Synchronous Transfer)
  - 데이터 전송이 클럭 신호에 맞춰 이루어지는 방식
  - 클럭 주기에 맞춰 데이터가 전송되기 때문에 예측 가능한 속도를 유지
  - 클럭 신호와 데이터 전송 타이밍을 정확히 맞춰야 함
- 비동기 전송(Asynchronous Transfer)
  - 데이터 전송이 클럭 신호와 독립적으로 이루어지는 방식
  - 스타트 비트와 스탑 비트를 이용하여 데이터의 전송 시작과 끝을 알림
- [DMA](#dmadirect-memory-access)
--- 		
## 프로세서 설계 (Processor Design)	
- 컴퓨터의 CPU를 구성하는 하드웨어 구조와 그 동작 방식을 정의하는 과정	
- 효율적인 데이터 처리, 빠른 명령어 실행, 낮은 전력 소모 등을 목표로 함
### 데이터 경로 설계 (Datapath Design)	
- 프로세서 내부에서 데이터가 이동하고 처리되는 경로를 설계하는 과정
#### 단일 사이클(Single-Cycle Design)
#### 멀티 사이클(Multi-Cycle Design)
### 제어 유닛 설계 (Control Unit Design)	
#### 하드와이어드 제어 (Hardwired Control)
#### 마이크로프로그램 제어 (Microprogrammed Control)
### 파이프라인 처리 (Pipelining)	
#### 파이프라인의 개념과 이점
- 프로세서 작업을 여러 단계로 분할하여 동시에 수행함으로써 처리 속도를 향상시키는 기술
- 일반적인 RISC 아키텍처에서 파이프라인은 5단계로 구성
  1. Instruction Fetch(IF) - 메모리에서 명령어를 가져오는 단계
  2. Instruction Decode(ID) - 명령어를 읽고 해독, 레지스터를 읽는 단계
  3. Excute(EX) - 연산 수행과 주소 계산을 하는 단계
  4. Memory Access(MEM) - 필요에 따라 메모리에서 데이터를 읽거나 쓰는 단계
  5. Write Back(WB) - 연산 결과를 레지스터에 기록하는 단계
![파이프라인](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Fivestagespipeline.png/300px-Fivestagespipeline.png)   
Image source : https://commons.wikimedia.org/wiki/File:Fivestagespipeline.png
- 이점
  - 여러 명령어가 동시에 다른 단계에서 병렬 처리되도록 함으로써, 초당 처리할 수 있는 명령어 수가 증가하여 전체 시스템의 처리량 및 처리 속도 향상
  - 여러 명령어가 동시에 처리되어 CPU 자원의 활용도가 높아짐
#### 위험 요소(Hazards)
- 파이프라인을 구성하는 여러 단계가 동시에 실행될 때 발생할 수 있는 문제
- 명령어의 순차적 처리에 간섭을 일으켜 성능을 저하시킬 수 있음
##### 데이터 위험(Data Hazards)
- 명령어 간의 데이터 종속성으로 인해 발생하는 위험
- 한 명령어가 이전 명령어의 결과를 필요로 할 때, 그 결과가 아직 처리되지 않아 발생하는 문제
- 원인
  - Read After Write(RAW)
    - 명령어가 이전 명령어가 쓰는 레지스터나 메모리 값을 읽어야 할 때 발생
    - 이전 명령어의 연산 결과값을 필요로 하는데, 연산이 완료되지 않아 올바른 값을 읽지 못하는 상황
  - Write After Write(WAW)
    - 두 개 이상의 명령어가 동일한 레지스터나 메모리 위치에 값을 쓸 때 발생
    - 두 번째 명령어가 첫 번째 명령어의 완료 전에 값을 덮어써 최종 결과가 달라지는 상황
  - Write After Read(WAR)
    - 한 명령어가 값을 읽은 후, 다른 명령어가 그 값을 덮어쓸 때 발생
    - 어느 명령어가 먼저 끝나느냐에 따라 값이 달라지는 상황
- 해결 기법
  - 포워딩(Forwarding)
    - 이전 명령어가 연산을 완료하기 전에 그 결과를 다음 명령어로 전달하여 위험을 방지
    - ALU의 출력이 레지스터에 저장되기 전에, 다음 명령어의 입력으로 전달
  - 파이프라인 스톨(Pipeline Stall)
    - 파이프라인의 일부 단계를 일시적으로 중단하여 위험을 해결
    - 위험이 발생하는 시점에 파이프라인에 버블(Bubble)을 삽입하여 필요한 데이터가 준비될 때 까지 다음 명령어의 실행을 지연
##### 제어 위험(Control Hazards)
- 분기 명령어(Branch Instruction)나 점프 명령어(Jump Instruction)로 인해 파이프라인의 흐름이 변경될 때 발상해는 위험
- 원인
  - 분기 명령어에 의해 이미 처리된 명령이 무효화 되는 상황
- 해결 기법
  - 분기 예측(Branch Prediction)
    - 분기 명령어의 결과를 예측하여 파이프라인의 흐름을 유지하는 기법
    - 예측된 분기 방향에 따라 명령어를 미리 페치하여, 예측이 맞으면 유지하고, 틀리면 잘못된 명령어를 취소하고 올바른 분기 방향으로 재설정
  - 분기 지연 슬롯(Branch Delayed Slot)
    - 분기 명령어 다음에 오는 명령어를 no-op나 분기문과 독립적인 명령어를 수행하도록 순서를 재배치하는 기법
##### 구조적 위험(Structural Hazards)
- 파이프라인의 여러 단계가 동일한 하드웨어 자원을 동시에 요구할 때 발생하는 위험
- 원인
  - 여러 파이프라인 단계가 메모리에 동시에 접근하는 등 동일한 자원을 공유할 때 발생
- 해결 기법
  - 동일한 하드웨어 자원을 동시에 사용할 수 있도록 하드웨어 자원을 늘리는 방법
--- 	
## 성능 평가와 최적화 (Performance Evaluation and Optimization)		
### 성능 측정 지표 (Performance Metrics)	
#### 처리량(Throughput), 응답 시간(Response Time), 클럭 주기(Clock Cycle)
### Amdahl의 법칙 (Amdahl's Law)	
- 컴퓨터 시스템의 일부를 개선할 때, 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산
- 주로 프로세서 개수에 따라 시스템 성능이 어느정도 향상되는지 계산하는데 사용
- $\frac{1}{(1-P)+\frac{P}{S}}$   
$P$는 병렬 처리가 가능한 부분, $S$는 프로세서 개수
### 시스템 성능 최적화 (System Performance Optimization)	
#### 캐시 최적화(Cache Optimization)
#### 분기 예측(Branch Prediction)